https://www.nowcoder.com/tutorial/94/ae05554a3ad84e42b6f9fc4d52859dc4
1.字符串转换编码
new String(str.getBytes(“ISO-8859-1″), “GBK”);
2.Java中是如何支持正则表达式操作
Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象
3.&和&&的区别
&用法  (1)按位与 二进制位全部为1则为1的运算符；(2)逻辑与  判断左右两侧条件
&&：短路与，左侧条件不成立不会判断右侧
4.int和Integer区别
 	Integer a = new Integer(3);
        Integer b = 3;                  // 将3自动装箱成Integer类型
        int c = 3;
        System.out.println(a == b);     // false 两个引用没有引用同一对象
        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较
5.Array和ArrayList的不同点
    Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
    Array大小是固定的，ArrayList的大小是动态变化的。
    ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
    对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。
6.值传递和引用传递
    值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.(等学会JVM 可以解释一下 堆和栈之间的关系)
    引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.
    一般认为,java内的传递都是值传递.
7.自动拆装箱 (基本数据类型Java语言支持的8种基本数据类型是：byte,short,int,long,float,double,boolean,char->Character)
    自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。
    比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱
8.出现4.0-3.6=0.40000001多位小数
    2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差
9.十进制的数在内存中存储方式
    补码  补码->原码  按位取反+1
    -5对应正数5（00000101）→所有位取反（11111010）→加1(11111011) 所以-5的补码是11111011
10.Lamda表达式的优缺点
    优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。
    缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。
11.java8的新特性 https://www.cnblogs.com/acker-ploy/p/12047906.html
    Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。
    方法引用− 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
    默认方法− 默认方法就是一个在接口里面有了一个实现的方法。
    新工具− 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
    Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
    Date Time API − 加强对日期与时间的处理。LocalDateTime LocalDate LocalTime
    Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
    Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。
12.“==”比较内容
    对象  对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。
    基本类型，就是比较数值是否相等
13.Object不重写hashCode()时hashCode()怎么计算
    Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址
14.重写equals为什么还要重写hashcode
    自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的
    重写hashCode()是为了对同一个key，能得到相同的HashCode码 HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的
    重写equals是为了对比向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对 才能比较对象
15.map的分类和常见的情况(重要)
    java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap
    共性:Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。
    Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
    Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为Null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。相对于HashMap更安全
    LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。
    TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。
    汇总:一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.
16.XML文档定义的几种形式，它们之间有何本质区别?解析XML文档又有哪几种方式
    两种形式 dtd schema
    dtd：数据类型定义（data type definition），用以描述XML文档的文档结构，是早期的XML文档定义形式。
    schema：其本身是基于XML语言编写的，在类型和语法上的限定能力比dtd强，处理也比较方便，因为此正逐渐代替dtd成为新的模式定义语言
    本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)
    解析方式有有DOM,SAX,STAX等
    DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问
    SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。
    当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问
    STAX:Streaming API for XML (StAX)
17. OSI七层协议模型、TCP/IP四层模型和五层协议体系结构之间的关系 (了解即可)TCP：运输层 IP：网络层HTTP：应用层
    OSI七层协议模型
        OSI的七层协议主要包括：
        物理层（physical layer）：RJ45、CLOCK、IEEE802.3（中继器、集线器）
            主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。
            他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。
        数据链路层（data link layer）：PPP、FR、HDLC、VLAN、MAC（网桥、交换机）
            定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输
        网络层（network layer）：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）
            在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
        运输层（transport layer）：TCP、UDP、SPX
            定义了一些传输数据的协议和端口号（WWW端口80等），如：
            TCP（传输控制协议TCP，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）和UDP（用户数据报协议UDP，
            与TCP特性恰恰相反，用于传输可靠性要求不高、数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。
            主要是将从下层的接收的数据进行分段和传输，到达目的地后再进行传输。常常把这一层数据叫做段。
        会话层（session layer）：NFS、SQL、NETBIOS、RPC
            通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。
            主要在你的系统之间发起会话或者就受会话请求（设备之间需要相互认识可以是IP地址也可以是MAC地址或者主机名）。
        表示层（presentation layer）：JPEG、MPEG、ASII
            可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
            例如，PC程序与另一台程序计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。
            如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换。
        应用层（application layer）：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
            是最靠近用户的OSI层。这一层为用户的应用程序（如：电子邮件、文件传输和仿真终端）提供网络服务
    TCP/IP是一个四层的体系结构，他包括（从下到上顺序）：
        网络接口层、
        网际层（用网际层这个名字是强调这一层是为了解决不同的网络的互联问题）、
        运输层、
        应用层。不过从实质上讲，TCP/IP只有最上面的三层，因为最下面的网络接口层并没有具体内容。
    五层协议体系结构
        五层体系的协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：
        物理层、
        数据链路层、
        网络层、
        运输层、
        应用层。（最底下两层可以称为网络接口层）
    注：五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构
    OSI由于体系比较复杂，而且设计先于实现，有许多设计过于思想，不太方便计算机软件实现，因而完全实现OSI参考模型的系统不多，应用的范围有限。
    TCP/IP协议最早在计算机系统中实现，在Linux、Windows平台中都有稳定的实现，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。
    TCP/IP协议已成为目前互联网事实上的国际标准和工业标准
18.TCP协议的4次握手 (ack 发送的确认字符 ,fin 发送结束字符)
    由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，
    一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
    TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。
    （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
    （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
    （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
    （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。
19.tcp为什么要建立连接,为什么TCP可靠一些
    建立连接是为了保证数据的可靠传输。
    TCP可靠是因为自身的机制三次握手成功才开始传输数据，超时重传，滑动窗口，拥塞控制
20.使用TCP协议的应用场景以及使用它的意义
    当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，
    比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议
21.TCP的连接和释放过程(了解即可)
    连接:三次握手
    释放:四次握手
    三次握手的过程
    1）主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；
    2）主机B收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1）
    3）第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；
    四次挥手过程
    假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：
    1） 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。
    2） 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。
    3） 关闭服务器到客户端的连接：也是发送一个FIN给客户端。
    4） 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
22.http请求中的304状态码的含义
    304(未修改)自从上次请求后，请求的网页未修改过。
    服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。
    服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
23.SSL四次握手的过程 (https与http 不同就在于https使用了ssl,TLS与SSL在传输层对网络连接进行加密  属于http和https不同点的延伸问题)
    1、 客户端发出请求
    首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
    2、服务器回应
    服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。
    3、客户端回应
    客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
    4、服务器的最后回应
    服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。
    （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
    （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
    至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。
    补充:SSl是一种安全协议。 SSL(Secure Sockets Layer)及其继任者传输层安全(Transport Layer Security,TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密
24.http1.1和1.0的区别(http1.1支持断点续传功能,http1.0不支持)
    缓存处理
        在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
        HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略
    带宽优化及网络连接的使用
        HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，
        HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
    错误通知的管理
        HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
    Host头处理
        HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。
        但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
        HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
    长连接
        HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，
        在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
25.http请求，并说明应答码502和504的区别
    502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
    504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
26.http请求方式
    OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
    HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。
    GET：向特定的资源发出请求。
    POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
    PUT：向指定资源位置上传其最新内容。
    DELETE：请求服务器删除Request-URI所标识的资源。
    TRACE：回显服务器收到的请求，主要用于测试或诊断。
    CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
    虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。
27.http和https的区别(重点要考)
    1） https协议要申请证书到ca，需要一定经济成本；
    2） http是明文传输，https是加密的安全传输；
    3） 连接的端口不一样，http是80，https是443；
    4） http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全
28.浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程
    1.DNS解析(主要是解析域名) 2.TCP连接(通过运输层来对IP和端口进行数据传输) 3.发送HTTP请求(对服务器进行请求发送) 4.服务器处理请求并返回HTTP报文(服务器响应) 5.浏览器解析渲染页面(呈现)
29.简述arp协议的工作原理以及ARP攻击
    ARP协议是一种地址解析协议。
        在每台安装有TCP/IP协议的电脑里都有一个ARP缓存表，表里的IP地址与MAC地址是一一对应的,如:
        我们以主机A（192.168.1.5）向主机B（192.168.1.1）发送数据为例。当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。
        如果找到了，也就知道了目标MAC地址，直接把目标MAC地址写入帧里面发送就可以了；如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播，
        目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.1.1的MAC地址是什么？”
        网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应：“192.168.1.1的MAC地址是00-aa-00-62-c6-09”。
        这样，主机A就知道了主机B的MAC地址，它就可以向主机B发送信息了。同时它还更新了自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可以了。
        ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。
    ARP攻击
        ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。
        ARP攻击主要是存在于局域网网络中，局域网中若有一个人感染ARP木马，则感染该ARP木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。
        ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，
        当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，
        每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，
        并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了
30.ICMP协议的定义以及作用
    它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用
31.路由器和交换机的区别 (路由器有交换机的功能，但是路由器比交换机复杂  协议层不同 数据不同 依据不同)
    1、工作层次不同：交换机比路由器更简单，路由器比交换器能获取更多信息,交换机工作在数据链路层，而路由器工作在网络层
    2、数据转发所依据的对象不同:
        交换机的数据转发依据是利用物理地址或者说MAC地址来确定转发数据的目的地址
        而路由器是依据ip地址进行工作的
    3、传统的交换机只能分割冲突域，不能分割广播域;而路由器可以分割广播域
    4、转发的数据对象不同 ，交换机转发的是数据帧、路由器转发的是分组报文
    安全性能 路由器一般有防火墙的功能，能够对一些网络数据包选择性过滤。
32.DNS的寻址过程(明白先检查浏览器缓存->hosts文件->本地DNS解析器缓存->TCP/ip参数中设置的首选DNS服务器  就已经够用了)
    1、在浏览器中输入www.qq.com域名，操作系统会先检查浏览器缓存、检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
    2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
    3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，
    如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
    4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。
    5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，
    6、如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。
    本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。
    当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。
    如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。
    不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。
    从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。
33.负载均衡 反向代理模式的优点、缺点 (需要再整理的简单明白一点 这个装逼好使)
    （1）反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。
    （2）反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。
    （3）反向代理负载均衡能以软件方式来实现，如apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。
        反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；
        由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT负载均衡技术也有此优点）。
    （4）其缺点主要表现在以下两个方面
        反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对web服务器的负载均衡。
        针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。
        一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如search等


