https://www.nowcoder.com/tutorial/94/ae05554a3ad84e42b6f9fc4d52859dc4
1.字符串转换编码
new String(str.getBytes(“ISO-8859-1″), “GBK”);
2.Java中是如何支持正则表达式操作
Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象
3.&和&&的区别
&用法  (1)按位与 二进制位全部为1则为1的运算符；(2)逻辑与  判断左右两侧条件
&&：短路与，左侧条件不成立不会判断右侧
4.int和Integer区别
 	Integer a = new Integer(3);
        Integer b = 3;                  // 将3自动装箱成Integer类型
        int c = 3;
        System.out.println(a == b);     // false 两个引用没有引用同一对象
        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较
5.Array和ArrayList的不同点
    Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
    Array大小是固定的，ArrayList的大小是动态变化的。
    ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
    对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。
6.值传递和引用传递
    值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.(等学会JVM 可以解释一下 堆和栈之间的关系)
    引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.
    一般认为,java内的传递都是值传递.
7.自动拆装箱 (基本数据类型Java语言支持的8种基本数据类型是：byte,short,int,long,float,double,boolean,char->Character)
    自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。
    比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱
8.出现4.0-3.6=0.40000001多位小数
    2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差
9.十进制的数在内存中存储方式
    补码  补码->原码  按位取反+1
    -5对应正数5（00000101）→所有位取反（11111010）→加1(11111011) 所以-5的补码是11111011
10.Lamda表达式的优缺点
    优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。
    缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。
11.java8的新特性 https://www.cnblogs.com/acker-ploy/p/12047906.html
    Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。
    方法引用− 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
    默认方法− 默认方法就是一个在接口里面有了一个实现的方法。
    新工具− 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
    Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
    Date Time API − 加强对日期与时间的处理。LocalDateTime LocalDate LocalTime
    Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
    Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。
12.“==”比较内容
    对象  对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。
    基本类型，就是比较数值是否相等
13.Object不重写hashCode()时hashCode()怎么计算
    Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址
14.重写equals为什么还要重写hashcode
    自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的
    重写hashCode()是为了对同一个key，能得到相同的HashCode码 HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的
    重写equals是为了对比向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对 才能比较对象
15.map的分类和常见的情况(重要)
    java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap
    共性:Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。
    Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
    Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为Null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。相对于HashMap更安全
    LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。
    TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。
    汇总:一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.
16.XML文档定义的几种形式，它们之间有何本质区别?解析XML文档又有哪几种方式
    两种形式 dtd schema
    dtd：数据类型定义（data type definition），用以描述XML文档的文档结构，是早期的XML文档定义形式。
    schema：其本身是基于XML语言编写的，在类型和语法上的限定能力比dtd强，处理也比较方便，因为此正逐渐代替dtd成为新的模式定义语言
    本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)
    解析方式有有DOM,SAX,STAX等
    DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问
    SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。
    当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问
    STAX:Streaming API for XML (StAX)
17. OSI七层协议模型、TCP/IP四层模型和五层协议体系结构之间的关系 (了解即可)TCP：运输层 IP：网络层HTTP：应用层
    OSI七层协议模型
        OSI的七层协议主要包括：
        物理层（physical layer）：RJ45、CLOCK、IEEE802.3（中继器、集线器）
            主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。
            他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。
        数据链路层（data link layer）：PPP、FR、HDLC、VLAN、MAC（网桥、交换机）
            定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输
        网络层（network layer）：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）
            在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
        运输层（transport layer）：TCP、UDP、SPX
            定义了一些传输数据的协议和端口号（WWW端口80等），如：
            TCP（传输控制协议TCP，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）和UDP（用户数据报协议UDP，
            与TCP特性恰恰相反，用于传输可靠性要求不高、数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。
            主要是将从下层的接收的数据进行分段和传输，到达目的地后再进行传输。常常把这一层数据叫做段。
        会话层（session layer）：NFS、SQL、NETBIOS、RPC
            通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。
            主要在你的系统之间发起会话或者就受会话请求（设备之间需要相互认识可以是IP地址也可以是MAC地址或者主机名）。
        表示层（presentation layer）：JPEG、MPEG、ASII
            可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
            例如，PC程序与另一台程序计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。
            如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换。
        应用层（application layer）：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
            是最靠近用户的OSI层。这一层为用户的应用程序（如：电子邮件、文件传输和仿真终端）提供网络服务
    TCP/IP是一个四层的体系结构，他包括（从下到上顺序）：
        网络接口层、
        网际层（用网际层这个名字是强调这一层是为了解决不同的网络的互联问题）、
        运输层、
        应用层。不过从实质上讲，TCP/IP只有最上面的三层，因为最下面的网络接口层并没有具体内容。
    五层协议体系结构
        五层体系的协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：
        物理层、
        数据链路层、
        网络层、
        运输层、
        应用层。（最底下两层可以称为网络接口层）
    注：五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构
    OSI由于体系比较复杂，而且设计先于实现，有许多设计过于思想，不太方便计算机软件实现，因而完全实现OSI参考模型的系统不多，应用的范围有限。
    TCP/IP协议最早在计算机系统中实现，在Linux、Windows平台中都有稳定的实现，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。
    TCP/IP协议已成为目前互联网事实上的国际标准和工业标准
18.TCP协议的4次握手 (ack 发送的确认字符 ,fin 发送结束字符)
    由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，
    一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
    TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。
    （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
    （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
    （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
    （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。
19.tcp为什么要建立连接,为什么TCP可靠一些
    建立连接是为了保证数据的可靠传输。
    TCP可靠是因为自身的机制三次握手成功才开始传输数据，超时重传，滑动窗口，拥塞控制
20.使用TCP协议的应用场景以及使用它的意义
    当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，
    比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议
21.TCP的连接和释放过程(了解即可)
    连接:三次握手
    释放:四次握手
    三次握手的过程
    1）主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；
    2）主机B收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1）
    3）第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；
    四次挥手过程
    假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：
    1） 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。
    2） 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。
    3） 关闭服务器到客户端的连接：也是发送一个FIN给客户端。
    4） 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
22.http请求中的304状态码的含义
    304(未修改)自从上次请求后，请求的网页未修改过。
    服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。
    服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
23.SSL四次握手的过程 (https与http 不同就在于https使用了ssl,TLS与SSL在传输层对网络连接进行加密  属于http和https不同点的延伸问题)
    1、 客户端发出请求
    首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
    2、服务器回应
    服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。
    3、客户端回应
    客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
    4、服务器的最后回应
    服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。
    （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
    （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
    至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。
    补充:SSl是一种安全协议。 SSL(Secure Sockets Layer)及其继任者传输层安全(Transport Layer Security,TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密
24.http1.1和1.0的区别(http1.1支持断点续传功能,http1.0不支持)
    缓存处理
        在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
        HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略
    带宽优化及网络连接的使用
        HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，
        HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
    错误通知的管理
        HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
    Host头处理
        HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。
        但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
        HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
    长连接
        HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，
        在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
25.http请求，并说明应答码502和504的区别
    502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
    504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
26.http请求方式
    OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
    HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。
    GET：向特定的资源发出请求。
    POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
    PUT：向指定资源位置上传其最新内容。
    DELETE：请求服务器删除Request-URI所标识的资源。
    TRACE：回显服务器收到的请求，主要用于测试或诊断。
    CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
    虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。
27.http和https的区别(重点要考)
    1） https协议要申请证书到ca，需要一定经济成本；
    2） http是明文传输，https是加密的安全传输；
    3） 连接的端口不一样，http是80，https是443；
    4） http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全
28.浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程
    1.DNS解析(主要是解析域名) 2.TCP连接(通过运输层来对IP和端口进行数据传输) 3.发送HTTP请求(对服务器进行请求发送) 4.服务器处理请求并返回HTTP报文(服务器响应) 5.浏览器解析渲染页面(呈现)
29.简述arp协议的工作原理以及ARP攻击
    ARP协议是一种地址解析协议。
        在每台安装有TCP/IP协议的电脑里都有一个ARP缓存表，表里的IP地址与MAC地址是一一对应的,如:
        我们以主机A（192.168.1.5）向主机B（192.168.1.1）发送数据为例。当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。
        如果找到了，也就知道了目标MAC地址，直接把目标MAC地址写入帧里面发送就可以了；如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播，
        目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.1.1的MAC地址是什么？”
        网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应：“192.168.1.1的MAC地址是00-aa-00-62-c6-09”。
        这样，主机A就知道了主机B的MAC地址，它就可以向主机B发送信息了。同时它还更新了自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可以了。
        ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。
    ARP攻击
        ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。
        ARP攻击主要是存在于局域网网络中，局域网中若有一个人感染ARP木马，则感染该ARP木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。
        ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，
        当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，
        每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，
        并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了
30.ICMP协议的定义以及作用
    它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用
31.路由器和交换机的区别 (路由器有交换机的功能，但是路由器比交换机复杂  协议层不同 数据不同 依据不同)
    1、工作层次不同：交换机比路由器更简单，路由器比交换器能获取更多信息,交换机工作在数据链路层，而路由器工作在网络层
    2、数据转发所依据的对象不同:
        交换机的数据转发依据是利用物理地址或者说MAC地址来确定转发数据的目的地址
        而路由器是依据ip地址进行工作的
    3、传统的交换机只能分割冲突域，不能分割广播域;而路由器可以分割广播域
    4、转发的数据对象不同 ，交换机转发的是数据帧、路由器转发的是分组报文
    安全性能 路由器一般有防火墙的功能，能够对一些网络数据包选择性过滤。
32.DNS的寻址过程(明白先检查浏览器缓存->hosts文件->本地DNS解析器缓存->TCP/ip参数中设置的首选DNS服务器  就已经够用了)
    1、在浏览器中输入www.qq.com域名，操作系统会先检查浏览器缓存、检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
    2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
    3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，
    如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
    4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。
    5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，
    6、如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。
    本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。
    当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。
    如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。
    不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。
    从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。
33.负载均衡 反向代理模式的优点、缺点 (需要再整理的简单明白一点 这个装逼好使)
    （1）反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。
    （2）反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。
    （3）反向代理负载均衡能以软件方式来实现，如apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。
        反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；
        由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT负载均衡技术也有此优点）。
    （4）其缺点主要表现在以下两个方面
        反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对web服务器的负载均衡。
        针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。
        一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如search等
34.操作系统64位和32位的区别(只是针对cpu设计的 64位系统兼容32位的软件,32位系统不兼容64位的软件)
    操作系统只是硬件和应用软件中间的一个平台。
    32位操作系统针对的32位的CPU设计。64位操作系统针对的64位的CPU设计。
    运行能力不同。64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量
35.CentOS 和 Linux的关系(CentOS来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成)
    CentOS是Linux众多得发行版本之一，
    linux有三大发行版本（：Slackware、debian、redhat）,
    Redhat有收费的商业版和免费的开源版,商业版的业内称之为RHEL系列，
    CentOS是来自于依照开放源代码规定而公布的源代码重新编译而成。
    可以用CentOS替代商业版的RHEL使用。两者的不同，CentOS不包含封闭源代码软件，是免费的。
36.CentOS与ubuntu的区别
    1. centos中新建的非root用户是没有sudo的权限的，如果需要使用sudo权限必须在/etc/sudoers 中加入账户和权限，所以切换到root账号的时候只需要输入：su，加入root账号的密码即可。
     在Ubuntu中，一般使用sudo+命令，如果是第一次使用会提示输入当前用户的密码（而不是root的密码）
    2. 在线安装软件中，centos使用的是yum命令，而ubuntu中使用的是apt-get命令。除此之外yum中还有一个从软件源中搜索摸个软件的方法：yum search + 软件名
    3. centos是来自于RedHat，所以centos支持rpm格式的安装，而ubuntu显然是不支持的。
    4. 毕竟是不同的公司做的不同的发行版，很多配置文件的位置和默认的文件路径都有很大区别
37.进程和线程的区别
    进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程
    1)一个程序至少有一个进程,一个进程至少有一个线程
    2)线程的划分尺度小于进程，使得多线程程序的并发性高
    3)进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率
    4)线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，
    所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些
    5)每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
38.系统线程数量上限
    Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。
    这个限制可以在/usr/include/bits/local_lim.h中查看 ，对 linuxthreads 这个值一般是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。
    这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程栈大小，一般情况下，这个值是8M=8192KB。
39.杀死一个进程的方法
    Windows- 任务管理器结束进程   Linux-  kill pid
40.socket编程的三种通信模型，BIO，NIO，AIO
    同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。其中BIO是一个连接一个线程。NIO是一个请求一个线程。AIO是一个有效请求一个线程。
    同步阻塞：应用程序在获取网络数据的时候，如果网络传输数据很慢，那么程序就一直等待，直到传输完毕为止。
    同步非阻塞：应用程序直接可以获取已经准备就绪的数据，无须等待
    异步非阻塞表示，线程不用挂起等待，内核告诉线程消息已经收到了，你先返回，我这边准备数据，下次再来
41.理解操作系统里的内存碎片及解决办法(单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片)
    内存碎片分为：内部碎片和外部碎片。
    内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；内部碎片是处于区域内部或页面内部的存储块。
        占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。
    外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域
        外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请
42.页式存储
    主存被等分成大小相等的片，称为主存块，又称为实页。
    当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为2n ,通常为1KB、2KB、2nKB等
43.系统如何提高并发性
    1、提高CPU并发计算能力
    （1）多进程&多线程
    （2）减少进程切换，使用线程，考虑进程绑定CPU
    （3）减少使用不必要的锁，考虑无锁编程
    （4）考虑进程优先级
    （5）关注系统负载
    2、改进I/O模型
    (1)DMA技术
    (2)异步I/O
    (3)改进多路I/O就绪通知策略，epoll
    (4)Sendfile
    (5)内存映射
    (6)直接I/O
44.解释一下，通常系统CPU比较高的原因
    1、首先查看是哪些进程的CPU占用率最高
    ps -aux --sort -pcpu | more
    # 定位有问题的线程可以用如下命令
    ps -mp pid -o THREAD,tid,time | more
    2、查看JAVA进程的每个线程的CPU占用率
    ps -Lp 5798 cu | more        # 5798是查出来进程PID
    3、追踪线程，查看负载过高的原因，使用JDK下的一个工具
    jstack 5798                        # 5798是PID
    jstack -J-d64 -m 5798       # -j-d64指定64为系统
    jstack 查出来的线程ID是16进制，可以把输出追加到文件，导出用记事本打开，再根据系统中的线程ID去搜索查看该ID的线程运行内容，可以和开发一起排查。
45.什么情况下会发生死锁及解决死锁的策略
    （一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。
    （二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。
    （三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。
    （四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系
    解决方法：银行家算法
46.hashCode() 和equals() 方法的重要性体现在什么地方
    Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，
    因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。
47.Java中的HashMap的工作原理
    HashMap类有一个叫做Entry的内部类。这个Entry类包含了key-value作为实例变量。 每当往hashmap里面存放key-value对的时候，都会为它们实例化一个Entry(1.8之后是node 1.7是entry)对象，这个Entry对象就会存储在前面提到的Entry数组table中。
    Entry具体存在table的那个位置是 根据key的hashcode()方法计算出来的hash值（来决定）
48.什么是hashmap(HashMap和Hashset都是无序的。)
    HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
    HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
    HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。
49.如何构造一致性 哈希算法
    先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），
    接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。
    这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。
50.Object作为HashMap的key的话，对Object有什么要求
    要求Object中hashcode不能变。
51.Java里面的final关键字
    当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法
    当用final修饰一个变量时，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
    使用final方法的原因有两个。
    第一个原因是把方法锁定，以防任何继承类修改它的含义；
    第二个原因是效率(早期的Java实现版本中，会将final方法转为内嵌调用,近的Java版本中，不需要使用final方法进行这些优化了)。
52.谈谈关于Synchronized和lock
    synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能
    Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
    synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
    Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
    通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
53.理解happens-before 规则？
    因为jvm会对代码进行编译优化，指令会出现重排序的情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。
    1. 规则一：程序的顺序性规则
    一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。
    对于这一点，可能会有疑问。顺序性是指，我们可以按照顺序推演程序的执行结果，但是编译器未必一定会按照这个顺序编译，但是编译器保证结果一定==顺序推演的结果。
    2. 规则二：volatile规则
    对一个volatile变量的写操作，happens-before后续对这个变量的读操作。
    3. 规则三：传递性规则
    如果A happens-before B，B happens-before C，那么A happens-before C。
    jdk1.5的增强就体现在这里。回到上面例子中，线程A中，根据规则一，对变量x的写操作是happens-before对变量v的写操作的，根据规则二，对变量v的写操作是happens-before对变量v的读操作的，最后根据规则三，也就是说，线程A对变量x的写操作，一定happens-before线程B对v的读操作，那么线程B在注释处读到的变量x的值，一定是42.
    4.规则四：管程中的锁规则
    对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。
    5.规则五：线程start()规则
    主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens before 线程B中的操作。
    6.规则六：线程join()规则
    主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。
54.volatile关键字的作用：
    保证了变量的可见性（visibility）。
        被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象
        线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。
        因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点：
    　　（1）修改volatile变量时会强制将修改后的值刷新的主内存中。
    　　（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的
    保证了变量的有序性。(见53-happens-before 规则)
55.请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么
    synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。
    synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。
    synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：
    1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
    2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
    3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
    4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。
    https://www.cnblogs.com/fnlingnzb-learner/p/10335662.html
56.什么是构造函数？什么是构造函数重载？什么是复制构造函数？
    当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
    Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
    Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。
57.请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
    Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。
    Java中的方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
58.请说明Query接口的list方法和iterate方法有什么区别？
    ①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。
    ②list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题
59.面向对象的“六原则一法则”
    （1）单一职责原则：一个类只做它该做的事情。其核心就是我们常说的"高内聚";
    （2）开闭原则：软件实体应当对扩展开放，对修改关闭;
    （3）依赖倒转原则：面向接口编程(声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代);
    （4）里氏替换原则：任何时候都可以用子类型替换掉父类型。
    （5）接口隔离原则：接口要小而专，绝不能大而全。
    （6）聚合复用原则：优先使用聚合关系复用代码(类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。)
    （7）迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。(低耦合)门面模式和调停者模式就是对迪米特法则的践行。
60.如何通过反射获取和设置对象私有字段的值
    可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值
    public static Object getValue(Object target, String fieldName) {
        Class<?> clazz = target.getClass();
        String[] fs = fieldName.split("\\.");
        try {
            for (int i = 0; i < fs.length - 1; i++) {
                Field f = clazz.getDeclaredField(fs[i]);
                f.setAccessible(true);
                target = f.get(target);
                clazz = target.getClass();
            }
            Field f = clazz.getDeclaredField(fs[fs.length - 1]);
            f.setAccessible(true);
            return f.get(target);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public static void setValue(Object target, String fieldName, Object value) {
        Class<?> clazz = target.getClass();
        String[] fs = fieldName.split("\\.");
        try {
            for (int i = 0; i < fs.length - 1; i++) {
                Field f = clazz.getDeclaredField(fs[i]);
                f.setAccessible(true);
                Object val = f.get(target);
                if (val == null) {
                    Constructor<?> c = f.getType().getDeclaredConstructor();
                    c.setAccessible(true);
                    val = c.newInstance();
                    f.set(target, val);
                }
                target = val;
                clazz = target.getClass();
            }
            Field f = clazz.getDeclaredField(fs[fs.length - 1]);
            f.setAccessible(true);
            f.set(target, value);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public static void main(String[] args) throws Exception {
        String str = "hello";
        Method m = str.getClass().getMethod("toUpperCase");
        System.out.println(m.invoke(str));  // HELLO
    }
61.JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？
    Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。
    在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。
    Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。
    一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。
    用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。
    throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。
    可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。
    如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。
62.　java接口可以是public 的，也可以是friendly的，但一定是abstracted的。
   　java接口里的方法只能是public的、abstract的。java1.8 static或者defalut修饰方法内可以写具体实现
   　java接口里的成员变量只能是public 的，static 的，final的；并且必须赋初值，否则通不过编译
63.说明一下final, finally, finalize的区别
    final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
    finally是异常处理语句结构的一部分，表示总是执行。在try-catch-finally语句中执行return语句,前面的return 都会被最后的所覆盖,最后导致只有finally的return生效。
    finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。
    特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。
　　 使用finalize还需要注意一个事，调用super.finalize();
    一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，
    然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。
64.面向对象的特征有哪些方面
    (1)抽象
    抽象就是忽略一个主题中与当前目标无关的那些方面,只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象(行为/方法)，二是数据抽象(属性)。
    (2)继承
    对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）
    派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
    (3)封装
    封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
    (4)多态
    多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
    多态的作用: 消除类型之间的耦合关系。产生多态的条件: 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。
65.说明Comparable和Comparator接口的作用以及它们的区别
    Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。
    Java提供了包含compare()和equals()两个方法的Comparator接口。
66.接口和抽象类的区别是什么？
    接口中所有的方法隐含的都是抽象的。
    而抽象类则可以同时包含抽象和非抽象的方法。
    类可以实现很多个接口，但是只能继承一个抽象类.
    类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
    Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。
    Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者 是 public。
    接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。 也可以参考 JDK8 中抽象类和接口的区别
67.Java是否支持多继承
    Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。
68.如何通过反射创建对象
    - 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
    - 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，
    例如：String.class.getConstructor(String.class).newInstance("Hello");
    第一种方法、通过Class的newInstance()方法只能使用默认的无参构造方法，第二种方法可以传入自定义参数
69.是否可以在static环境中访问非static变量
    不可以，因为static变量是属于类的，在类加载的时候就被初始化了，这时候非静态变量并没有加载，故非静态变量不能访问。
70.解释一下extends 和super 泛型限定符
    （1）泛型中上界和下界的定义
    上界<? extend Fruit> Fruit的某个子类
    下界<? super Apple> Apple的某个父类
    （2）上界和下界的特点
    上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）
    下界的list只能add，不能get
    （3）示例代码
    import java.util.ArrayList;
    import java.util.List;

    class Fruit {}
    class Apple extends Fruit {}
    class Jonathan extends Apple {}
    class Orange extends Fruit {}

    public class CovariantArrays {
      public static void main(String[] args) {
        //上界
        List<? extends Fruit> flistTop = new ArrayList<Apple>();
        flistTop.add(null);
        //add Fruit对象会报错
        //flist.add(new Fruit());
        Fruit fruit1 = flistTop.get(0);

        //下界
        List<? super Apple> flistBottem = new ArrayList<Apple>();
        flistBottem.add(new Apple());
        flistBottem.add(new Jonathan());
        //get Apple对象会报错
        //Apple apple = flistBottem.get(0);
      }
    }
71.什么是泛型
    1.泛型，即“参数化类型”，本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
    2.这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。
    3.泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写 体验泛型。代码时定义一些可变部份，那些部份在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。
    4.泛型类是引用类型，是堆对象，主要是引入了类型参数这个概念。
    解决元素存储的安全性问题
    解决获取数据元素时，需要类型强转的问题
72.Java的泛型是如何工作的 ? 什么是类型擦除 ?
    泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List在运行时仅用一个List来表示。
    这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。
73.说明静态变量存在什么位置
    一、堆区:
    1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
    2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身
    栈区:
    1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
    2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
    3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
    方法区:
    1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
    2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
    二、内存分区
    而内存分为四个区：stack segment，heap segment，data segment，code segment；
    stack 区存放函数参数和局部变量；heap  区存放对象；data  区存放static 的变量或者字符串常量； code  区存放类中的方法；因此，静态变量是存放在data区的
74.解释一下类加载机制，双亲委派模型，好处是什么？
    JVM把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是JVM的类加载机制
    在加载阶段虚拟机需要完成以下三件事：
    1）通过一个类的全限定名称来获取此类的二进制字节流，并加载到内存中（需要使用类加载器）
    2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    3）在堆中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口（所以反射通过类对象可以访问到字段）
75.List、Map、Set三个接口存取元素时，各有什么特点
    List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。
    Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。
    Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。
76.ArrayList、Vector、LinkedList的存储性能和特性
    ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，
    Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，
    形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
    Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，
    如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。
77.请判断List、Set、Map是否继承自Collection接口？
   List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。
78.你所知道的常用集合类以及主要方法
    Collection
    ├List
    │├LinkedList
    │├ArrayList
    │└Vector
    │　└Stack
    └Set
    Map
    ├Hashtable
    ├HashMap
    └WeakHashMap
    List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。
    Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作"键"和"值"），其中每个键映射到一个值。
79.Collection 和 Collections的区别。
    Collection是集合类的上级接口，继承与他的接口主要有Set 和List.
    Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作
80.ArrayList和LinkedList的区别
    ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
    ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
    相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
    LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
81.HashMap和Hashtable的区别
    HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
    HashMap允许键和值是null，而Hashtable不允许键或者值是null。
    Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
    HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
    一般认为Hashtable是一个遗留的类。
82.快速失败(fail-fast)和安全失败(fail-safe)的区别
    Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。
    java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。
    快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。
83.Iterator和ListIterator的区别
    Iterator和ListIterator的区别是：
    Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
    Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
    ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。
84.什么是迭代器？
    Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,
    每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.
    有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.
85.为什么集合类没有实现Cloneable和Serializable接口
    克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。
    实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。
    实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。21521









